import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var Y3=function(a,b,c,d){return $APP.Be(new $APP.F(null,2,5,$APP.H,[d,null],null),new $APP.k(null,3,[eFa,a,fFa,b,gFa,c],null))},Z3=function(a){return a.g?a.g(0):a.call(null,0)},$3=function(a){var b=Z3(a);a=eFa.g($APP.Ce(a));return a.g?a.g(b):a.call(null,b)},a4=function(a){if($APP.l($3(a))){var b=Z3(a);a=fFa.g($APP.Ce(a));return a.g?a.g(b):a.call(null,b)}throw"called children on a leaf node";},b4=function(a,b,c){a=gFa.g($APP.Ce(a));return a.h?a.h(b,c):a.call(null,b,c)},g4=function(a){if($APP.l($3(a))){var b=
$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=a4(a),e=$APP.u(d),f=$APP.x(e);e=$APP.y(e);return $APP.l(d)?$APP.Be(new $APP.F(null,2,5,$APP.H,[f,new $APP.k(null,4,[c4,$APP.Nh,d4,$APP.l(c)?$APP.mg.h(d4.g(c),b):new $APP.F(null,1,5,$APP.H,[b],null),e4,c,f4,e],null)],null),$APP.Ce(a)):null}return null},i4=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=$APP.Sg(c);c=$APP.Xe.h(d,c4);var e=$APP.Xe.h(d,e4),f=$APP.Xe.h(d,d4),h=$APP.Xe.h(d,f4);d=$APP.Xe.h(d,h4);return $APP.l(f)?(f=$APP.De(f),$APP.Be($APP.l(d)?
new $APP.F(null,2,5,$APP.H,[b4(a,f,$APP.J.h(c,$APP.pg(b,h))),$APP.l(e)?$APP.Gj.j(e,h4,!0):e],null):new $APP.F(null,2,5,$APP.H,[f,e],null),$APP.Ce(a))):null},j4=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.Sg(c);var d=$APP.Xe.h(c,c4),e=$APP.Xe.h(c,f4),f=$APP.u(e),h=$APP.x(f);f=$APP.y(f);return $APP.l($APP.l(c)?e:c)?$APP.Be(new $APP.F(null,2,5,$APP.H,[h,$APP.Gj.l(c,c4,$APP.mg.h(d,b),$APP.B([f4,f]))],null),$APP.Ce(a)):null},k4=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);
c=$APP.Sg(c);var d=$APP.Xe.h(c,c4),e=$APP.Xe.h(c,f4);return $APP.l($APP.l(c)?e:c)?$APP.Be(new $APP.F(null,2,5,$APP.H,[$APP.we(e),$APP.Gj.l(c,c4,$APP.qh.C($APP.mg,d,b,$APP.Pj(e)),$APP.B([f4,null]))],null),$APP.Ce(a)):a},hFa=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.Sg(c);var d=$APP.Xe.h(c,c4),e=$APP.Xe.h(c,f4);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Be(new $APP.F(null,2,5,$APP.H,[$APP.De(d),$APP.Gj.l(c,c4,$APP.Ee(d),$APP.B([f4,$APP.pg(b,e)]))],null),$APP.Ce(a)):null},l4=function(a,
b){$APP.A.j(a,0,null);var c=$APP.A.j(a,1,null);return $APP.Be(new $APP.F(null,2,5,$APP.H,[b,$APP.Gj.j(c,h4,!0)],null),$APP.Ce(a))},iFa=new $APP.t("clojure.zip","path","clojure.zip/path",1758958974,null),jFa=new $APP.t("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),kFa=new $APP.t("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),lFa=new $APP.t("clojure.zip","down","clojure.zip/down",1356031458,null),mFa=new $APP.E(null,"content","content",15833224),m4=new $APP.t(null,
"make-node","make-node",-1550461835,null),gFa=new $APP.E("zip","make-node","zip/make-node",1103800591),nFa=new $APP.t("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),oFa=new $APP.t("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),pFa=new $APP.t(null,"insert-right","insert-right",1842751767,null),qFa=new $APP.t("clojure.zip","prev","clojure.zip/prev",-389017676,null),rFa=new $APP.t("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),sFa=new $APP.t("clojure.zip",
"insert-child","clojure.zip/insert-child",-210602132,null),tFa=new $APP.t("clojure.zip","end?","clojure.zip/end?",381053413,null),uFa=new $APP.t("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),h4=new $APP.E(null,"changed?","changed?",-437828330),vFa=new $APP.t(null,"zipper","zipper",-1153741331,null),wFa=new $APP.t("clojure.zip","left","clojure.zip/left",1740332703,null),xFa=new $APP.t(null,"append-child","append-child",-1707191801,null),yFa=new $APP.t("clojure.zip","root","clojure.zip/root",
-1119588559,null),zFa=new $APP.t(null,"insert-left","insert-left",1917369949,null),AFa=new $APP.t(null,"lefts","lefts",1054400638,null),BFa=new $APP.t(null,"vector-zip","vector-zip",1075131029,null),CFa=new $APP.t(null,"insert-child","insert-child",347166277,null),DFa=new $APP.t("clojure.zip","node","clojure.zip/node",-1345203614,null),EFa=new $APP.t("clojure.zip","edit","clojure.zip/edit",-442418038,null),FFa=new $APP.t("clojure.zip","remove","clojure.zip/remove",859584278,null),GFa=new $APP.t("clojure.zip",
"zipper","clojure.zip/zipper",-571036006,null),n4=new $APP.t(null,"item","item",1889905329,null),HFa=new $APP.t("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),IFa=new $APP.t(null,"rightmost","rightmost",-1854156251,null),JFa=new $APP.t("clojure.zip","next","clojure.zip/next",-1526224397,null),fFa=new $APP.E("zip","children","zip/children",-940194589),KFa=new $APP.t(null,"up","up",1370819414,null),LFa=new $APP.t("clojure.zip","rights","clojure.zip/rights",1361118051,null),MFa=
new $APP.t("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),NFa=new $APP.t("clojure.zip","up","clojure.zip/up",1006365229,null),OFa=new $APP.t("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),PFa=new $APP.t("clojure.zip","children","clojure.zip/children",65376544,null),QFa=new $APP.t("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),RFa=new $APP.t(null,"seq-zip","seq-zip",-2034709283,null),SFa=new $APP.t(null,"down","down",-1089190199,null),TFa=new $APP.t(null,
"rights","rights",2003591322,null),f4=new $APP.E(null,"r","r",-471384190),UFa=new $APP.t(null,"leftmost","leftmost",-1158121305,null),d4=new $APP.E(null,"pnodes","pnodes",1739080565),c4=new $APP.E(null,"l","l",1395893423),VFa=new $APP.t("clojure.zip","right","clojure.zip/right",-1593586409,null),WFa=new $APP.t(null,"xml-zip","xml-zip",-1566989793,null),e4=new $APP.E(null,"ppath","ppath",-1758182784),o4=new $APP.t(null,"loc","loc",1056246626,null),XFa=new $APP.t("clojure.zip","replace","clojure.zip/replace",
413367034,null),YFa=new $APP.t(null,"end?","end?",217139918,null),eFa=new $APP.E("zip","branch?","zip/branch?",-998880862),ZFa=new $APP.t("clojure.zip","lefts","clojure.zip/lefts",538689815,null);var p4=function p4(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return p4.l(arguments[0],arguments[1],2<c.length?new $APP.Kd(c.slice(2),0,null):null)};p4.l=function(a,b,c){return l4(a,$APP.qh.j(b,Z3(a),c))};p4.o=2;p4.v=function(a){var b=$APP.x(a),c=$APP.y(a);a=$APP.x(c);c=$APP.y(c);return this.l(b,a,c)};var $Fa=$APP.hV.h($APP.XO,null),aGa=$APP.Vx($APP.kj([$APP.Be(vFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,4,5,$APP.H,[$APP.sF,$APP.QB,m4,$APP.TL],null))),$APP.O,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)),$APP.Be(KFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)),$APP.Be($APP.$la,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)),$APP.Be(pFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,2,5,
$APP.H,[o4,n4],null))),$APP.O,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)),$APP.Be(zFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null))),$APP.O,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)),$APP.Be(YFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns true if loc represents the end of a depth-first walk"],null)),$APP.Be($APP.UN,
new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the node at loc"],null)),$APP.Be($APP.hR,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,$APP.UN],null))),$APP.O,"Replaces the node at this loc, without moving"],null)),$APP.Be($APP.$ia,new $APP.k(null,3,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,4,5,$APP.H,[o4,$APP.jI,$APP.Il,$APP.VL],null))),$APP.O,"Replaces the node at this loc with the value of (f node args)",
$APP.RJ,new $APP.k(null,6,[$APP.JE,!0,$APP.Mv,2,$APP.JP,2,$APP.eO,new $APP.F(null,1,5,$APP.H,[$APP.I(o4,$APP.jI,$APP.VL)],null),$APP.Y,$APP.I(new $APP.F(null,4,5,$APP.H,[o4,$APP.jI,$APP.Il,$APP.VL],null)),$APP.kQ,$APP.I(null)],null)],null)),$APP.Be(RFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[$APP.TL],null))),$APP.O,"Returns a zipper for nested sequences, given a root sequence"],null)),$APP.Be($APP.yK,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,
1,5,$APP.H,[o4],null))),$APP.O,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)),$APP.Be(WFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[$APP.TL],null))),$APP.O,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)),$APP.Be(BFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[$APP.TL],
null))),$APP.O,"Returns a zipper for nested vectors, given a root vector"],null)),$APP.Be(m4,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,3,5,$APP.H,[o4,$APP.UN,$APP.QB],null))),$APP.O,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)),$APP.Be($APP.sF,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns true if the node at loc is a branch"],null)),$APP.Be($APP.Ega,
new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the loc of the right sibling of the node at this loc, or nil"],null)),$APP.Be($APP.Aka,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns a seq of nodes leading to this loc"],null)),$APP.Be($APP.TL,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"zips all the way up and returns the root node, reflecting any\n changes."],
null)),$APP.Be(TFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns a seq of the right siblings of this loc"],null)),$APP.Be($APP.QB,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns a seq of the children of node at loc, which must be a branch"],null)),$APP.Be(UFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the loc of the leftmost sibling of the node at this loc, or self"],
null)),$APP.Be(SFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)),$APP.Be($APP.Oha,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the loc of the left sibling of the node at this loc, or nil"],null)),$APP.Be(AFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),
$APP.O,"Returns a seq of the left siblings of this loc"],null)),$APP.Be(CFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null))),$APP.O,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)),$APP.Be(xFa,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null))),$APP.O,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)),$APP.Be(IFa,new $APP.k(null,2,[$APP.Y,
$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)),$APP.Be($APP.IE,new $APP.k(null,2,[$APP.Y,$APP.I($APP.Xl,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null))),$APP.O,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null))],[new $APP.k(null,3,[$APP.P,GFa,$APP.Ux,Y3,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,4,5,$APP.H,[$APP.sF,$APP.QB,m4,
$APP.TL],null)),$APP.O,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],null)],null),new $APP.k(null,3,[$APP.P,NFa,$APP.Ux,i4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,
1,5,$APP.H,[o4],null)),$APP.O,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.k(null,3,[$APP.P,qFa,$APP.Ux,function(a){var b=hFa(a);if($APP.l(b))for(a=b;;)if(b=$3(a),b=$APP.l(b)?g4(a):b,$APP.l(b))a=k4(b);else return a;else return i4(a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)],null),new $APP.k(null,
3,[$APP.P,rFa,$APP.Ux,function(a,b){var c=$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.Sg(d);var e=$APP.Xe.h(d,f4);if(null==d)throw"Insert at top";return $APP.Be(new $APP.F(null,2,5,$APP.H,[c,$APP.Gj.l(d,f4,$APP.pg(b,e),$APP.B([h4,!0]))],null),$APP.Ce(a))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null)),$APP.O,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.P,HFa,$APP.Ux,function(a,b){var c=
$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.Sg(d);var e=$APP.Xe.h(d,c4);if(null==d)throw"Insert at top";return $APP.Be(new $APP.F(null,2,5,$APP.H,[c,$APP.Gj.l(d,c4,$APP.mg.h(e,b),$APP.B([h4,!0]))],null),$APP.Ce(a))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null)),$APP.O,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.k(null,3,[$APP.P,tFa,$APP.Ux,function(a){return $APP.z.h($APP.HC,a.g?a.g(1):a.call(null,
1))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.k(null,3,[$APP.P,DFa,$APP.Ux,Z3,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns the node at loc"],null)],null),new $APP.k(null,3,[$APP.P,XFa,$APP.Ux,l4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,$APP.UN],null)),$APP.O,"Replaces the node at this loc, without moving"],
null)],null),new $APP.k(null,3,[$APP.P,EFa,$APP.Ux,p4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,4,5,$APP.H,[o4,$APP.jI,$APP.Il,$APP.VL],null)),$APP.O,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.k(null,3,[$APP.P,oFa,$APP.Ux,function(a){return Y3($APP.Qe,$APP.mf,function(b,c){return $APP.Be(c,$APP.Ce(b))},a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[$APP.TL],null)),$APP.O,"Returns a zipper for nested sequences, given a root sequence"],
null)],null),new $APP.k(null,3,[$APP.P,JFa,$APP.Ux,function(a){if($APP.z.h($APP.HC,a.g?a.g(1):a.call(null,1)))return a;var b=$3(a);b=$APP.l(b)?g4(a):b;if($APP.l(b))return b;b=j4(a);if($APP.l(b))return b;for(;;)if($APP.l(i4(a))){b=j4(i4(a));if($APP.l(b))return b;a=i4(a)}else return new $APP.F(null,2,5,$APP.H,[Z3(a),$APP.HC],null)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],
null)],null),new $APP.k(null,3,[$APP.P,kFa,$APP.Ux,function(a){return Y3($APP.rh($APP.xb),$APP.zs.h($APP.u,mFa),function(b,c){return $APP.Gj.j(b,mFa,$APP.l(c)?$APP.qh.h($APP.lA,c):c)},a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[$APP.TL],null)),$APP.O,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)],null),new $APP.k(null,3,[$APP.P,uFa,$APP.Ux,function(a){return Y3($APP.Me,$APP.u,function(b,c){return $APP.Be($APP.fi(c),$APP.Ce(b))},
a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[$APP.TL],null)),$APP.O,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.k(null,3,[$APP.P,OFa,$APP.Ux,b4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,3,5,$APP.H,[o4,$APP.UN,$APP.QB],null)),$APP.O,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)],null),new $APP.k(null,3,[$APP.P,MFa,$APP.Ux,$3,$APP.eb,new $APP.k(null,
2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns true if the node at loc is a branch"],null)],null),new $APP.k(null,3,[$APP.P,VFa,$APP.Ux,j4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.P,iFa,$APP.Ux,function(a){return d4.g(a.g?a.g(1):a.call(null,1))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),
$APP.O,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.k(null,3,[$APP.P,yFa,$APP.Ux,function(a){for(;;){if($APP.z.h($APP.HC,a.g?a.g(1):a.call(null,1)))return Z3(a);var b=i4(a);if($APP.l(b))a=b;else return Z3(a)}},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),new $APP.k(null,3,[$APP.P,LFa,$APP.Ux,function(a){return f4.g(a.g?a.g(1):a.call(null,1))},$APP.eb,
new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.P,PFa,$APP.Ux,a4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.k(null,3,[$APP.P,QFa,$APP.Ux,function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.Sg(c);var d=$APP.Xe.h(c,c4),e=$APP.Xe.h(c,
f4);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Be(new $APP.F(null,2,5,$APP.H,[$APP.x(d),$APP.Gj.l(c,c4,$APP.Nh,$APP.B([f4,$APP.J.l($APP.Od(d),new $APP.F(null,1,5,$APP.H,[b],null),$APP.B([e]))]))],null),$APP.Ce(a)):a},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),new $APP.k(null,3,[$APP.P,lFa,$APP.Ux,g4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,
[o4],null)),$APP.O,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)],null),new $APP.k(null,3,[$APP.P,wFa,$APP.Ux,hFa,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.P,ZFa,$APP.Ux,function(a){return $APP.u(c4.g(a.g?a.g(1):a.call(null,1)))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,
[o4],null)),$APP.O,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.P,sFa,$APP.Ux,function(a,b){return l4(a,b4(a,Z3(a),$APP.pg(b,a4(a))))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null)),$APP.O,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.P,nFa,$APP.Ux,function(a,b){return l4(a,b4(a,Z3(a),$APP.J.h(a4(a),new $APP.F(null,1,5,$APP.H,[b],null))))},$APP.eb,
new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,2,5,$APP.H,[o4,n4],null)),$APP.O,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.P,jFa,$APP.Ux,k4,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),$APP.O,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],null),new $APP.k(null,3,[$APP.P,FFa,$APP.Ux,function(a){$APP.A.j(a,0,null);var b=$APP.A.j(a,1,null);b=$APP.Sg(b);
var c=$APP.Xe.h(b,c4),d=$APP.Xe.h(b,e4),e=$APP.Xe.h(b,d4),f=$APP.Xe.h(b,f4);if(null==b)throw"Remove at top";if(0<$APP.me(c))for(a=$APP.Be(new $APP.F(null,2,5,$APP.H,[$APP.De(c),$APP.Gj.l(b,c4,$APP.Ee(c),$APP.B([h4,!0]))],null),$APP.Ce(a));;)if(b=$3(a),b=$APP.l(b)?g4(a):b,$APP.l(b))a=k4(b);else return a;else return $APP.Be(new $APP.F(null,2,5,$APP.H,[b4(a,$APP.De(e),f),$APP.l(d)?$APP.Gj.j(d,h4,!0):d],null),$APP.Ce(a))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.I(new $APP.F(null,1,5,$APP.H,[o4],null)),
$APP.O,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null)],null)]),$Fa);$APP.Sy(new $APP.k(null,1,[$APP.Ws,new $APP.k(null,1,[$APP.XO,aGa],null)],null));